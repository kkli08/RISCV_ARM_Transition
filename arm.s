# CMPUT 229 Student Submission License
# Version 1.0
#
# Copyright 2021 <Ke Li>
#
# Redistribution is forbidden in all circumstances. Use of this
# software without explicit authorization from the author or CMPUT 229
# Teaching Staff is prohibited.
#
# This software was produced as a solution for an assignment in the course
# CMPUT 229 - Computer Organization and Architecture I at the University of
# Alberta, Canada. This solution is confidential and remains confidential 
# after it is submitted for grading.
#
# Copying any part of this solution without including this copyright notice
# is illegal.
#
# If any portion of this software is included in a solution submitted for
# grading at an educational institution, the submitter will be subject to
# the sanctions for plagiarism at that institution.
#
# If this software is found in any public website or public repository, the
# person finding it is kindly requested to immediately report, including 
# the URL or other repository locating information, to the following email
# address:
#
#          cmput229@ualberta.ca
#
#---------------------------------------------------------------
# CCID:                 <  kli1  >
# Lecture Section:      <  A1  >
# Instructor:           <  Jose Nelson Amaral  >
# Lab Section:          <  D04  >
# Teaching Assistant:   <  Soodarshan Gajadhur  >
#---------------------------------------------------------------
# 

.data
.align 2
# space for RISCV to ARM Table
RISCTOARMTable:		.space 2048
# space for Branch Table
BranchTable:		.space 2048

# count the num
secondPass:			.word 0
num: 				.word 0

.include "common.s"
# NOTE: for the below to work, you must delete the .include "common.s" from your arm_alu.s file
.include "arm_alu.s" 

#----------------------------------
#        STUDENT SOLUTION
#----------------------------------

#-------------------------------------------------------------------------------------------------------------------------
# RISCVtoARM
# This function translates RISC-V code in memory at address found in a0 into ARM code and stores that ARM code into the memory address found in a1.
# Arguments:
# a0: pointer to memory containing a RISC-V function. The end of the RISC-V instructions is marked by the sentinel word 0xFFFFFFFF.
# a1: a pointer to preallocated memory where you will have to write ARM instructions.
# Return Values:
# a0: number of bytes worth of instructions generated by RISCVtoARM.
#-------------------------------------------------------------------------------------------------------------------------
RISCVtoARM:
	
	# Block description:
	# create space for the stack and store all the registers
	addi	sp, sp, -64
	sw	ra, 0(sp)
	sw	s0, 4(sp)	# set s0 to the address of a0
	sw	s1, 8(sp)
	sw	s2, 12(sp)	# set s2 to the address of a1
	sw	s3, 16(sp)	# 20th bit for each RISCV instruction
	sw	a1, 20(sp)
	sw	s4, 24(sp)
	sw	s5, 28(sp)	# set num = 0 at begin
	sw	s6, 32(sp)	# Address of RISCV To ARM Table 
	sw	s7, 36(sp)	# Address of Branch Table
	sw	a1, 40(sp)
	#-------------------
	sw	s8, 44(sp)
	sw	s9, 48(sp)
	sw	s10, 52(sp)
	sw	s11, 56(sp)
	sw	a0, 60(sp)
	
	
	# load the register that will use later on
	mv	s0, a0		# set s0 to the address of a0
	mv	s2, a1
	sw	s2, 12(sp)	# set s2 to the address of a1
	
	# load the address for those 2 tables
	la	s6, RISCTOARMTable
	la	s7, BranchTable
	
	# Jump to the first pass loop 
	# if there has instruction to be translated
	li	t0, 0xFFFFFFFF	# t0 = -1
	lw	t1, 0(s0)
	bne	t1, t0, TransferrenewLoop1	# goto Transfer if s0 != -1
	j	QuitRToA	# jump to QuitRToA
	
	TransferrenewLoop1:
		# This is the main loop for the first pass that 
		# used for translate riscv instructions to arm instructions
		# and store all the address into RISCTOARMTable and BranchTable
		#--------------------------------------------------------------
		# this block is used for indentify which kind of instructions should 
		# be translated ( branch instruction or alu instruction )
		lw	a0, 0(s0)	# a0 = 0(s0)
		slli	s3, a0, 25	# set s3 to the 20th bit
		srli	s3, s3, 31
		li	t3, 1
		bne	s3, t3, TransferAlu	# jump to TransferAlu if 2oth bit == 0
		#--------------------------------------------------------------
		# load the RISCTOARMTable & BranchTable
		lw	s6, 32(sp)
		la	s6, RISCTOARMTable
		lw	s7, 36(sp)
		la	s7, BranchTable
		#-----------------------
		# get the address of current address of RISCTOARMTable & 
		# BranchTable for current instruction
		slli	t3, s5, 2	# left shift by 2
		
		add	s6, s6, t3	# get the address of current address of RISCTOARMTable
		add	s7, s7, t3	# get the address of current address of BranchTable
		
		sw	a1, 0(s6) 	# store the value into RISCTOARMTable
		la	t5, RISCTOARMTable	# load the address
		add	t5, t5, t3	
		lw	t6, 0(t5)
		#----------------
		# translate branch instructions
		jal	ra, translateControl	# jump to translateALU
		
		mv	t4, a0		# the first instruction that has translated
		mv	s4, a1		# the second instruction that has translated
		
		beq	s4, zero, storeJALR	# jumo to storeJALR if s4 == null
		#-----------------------
		# get the address of current address of RISCTOARMTable & 
		# BranchTable for current instruction
		slli	t3, s5, 2
		la	s6, RISCTOARMTable
		add	s6, s6, t3
		la	s7, BranchTable
		add	s7, s7, t3
		
		# Jump to caculateRISCVBranchOffset
		lw	a0, 0(s0)	# load a0
		jal	ra, caculateRISCVBranchOffset	# Jump to caculateRISCVBranchOffset
		
		# Get the offset in RISCV instruction and get store
		# the branch address into BranchTable
		mv	s8, a0		# s8 = a0
		lw	t1, 0(s0)	# load t1
		add	t0, s6, s8	# t0 = s6 + s8
		sw	t0, 0(s7)	# store the value into BranchTable
		#-----------------------
		# get the address of current address of RISCTOARMTable & 
		# BranchTable for current instruction
		lw	s6, 32(sp)
		la	s6, RISCTOARMTable
		lw	s7, 36(sp)
		la	s7, BranchTable
		#-----------------------
		# load & store the register that will use later on
		lw	a1, 20(sp)
		sw	t4, 0(a1)	# store s2 into 0(a1)
		sw	s4, 4(a1)
		
		addi	a1, a1, 8	# append a1 by 4
		sw	a1, 20(sp)
		
		lw	s5, 28(sp)	# append s5 and store s5 into stack
		addi	s5, s5, 1
		sw	s5, 28(sp)
		addi	s0, s0, 4	# append s0 by 4
		addi	s1, s1, 8	# append s1 by 8
		lw	t2, 0(s0)	# load t2 = 0(s0)
		li	t0, 0xFFFFFFFF	# load t0 = -1
		bne  	t2, t0, TransferrenewLoop1	# jump back to the begining of the loop of t2 != -1
		j	TransferrenewLoop2	# jump to TransferrenewLoop2
		#--------------------------------------------------------------
		storeJALR:
		# this block is used for store translated JALR instructions
		lw	a1, 20(sp)
		sw	t4, 0(a1)	# store s2 into 0(a1)
		
		addi	a1, a1, 4	# append a1 by 4
		sw	a1, 20(sp)
		
		lw	s5, 28(sp)	# append s5 and store s5 into stack
		addi	s5, s5, 1
		sw	s5, 28(sp)
		
		addi	s0, s0, 4	# append s0 by 4
		addi	s1, s1, 4	# append s1 by 8
		lw	t2, 0(s0)	# load t2 = 0(s0)
		li	t0, 0xFFFFFFFF	# load t0 = -1
		bne  	t2, t0, TransferrenewLoop1	# jump back to the begining of the loop of t2 != -1
		j	TransferrenewLoop2	# jump to TransferrenewLoop2
		
		#--------------------------------------------------------------
		# translate ALU instructions
		TransferAlu:
		# This blcok is used for storing translated alu instructions
		jal	ra, translateALU	# jump to translateALU
		
		lw	s6, 32(sp)
		la	s6, RISCTOARMTable	# load the address of RISCTOARMTable
		#-----------------------
		# This block store the appended value in s5
		# And also store the instruction address into RISCTOARMTable
		lw	s5, 28(sp)
		slli	t3, s5, 2	# t3 = s5 * 4
		addi	s5, s5, 1	# s5 += 1
		sw	s5, 28(sp)

		add	s6, s6, t3	# s6 += t3
		sw	a1, 0(s6)
		lw	s6, 32(sp)
		la	s6, RISCTOARMTable	# load the address of RISCTOARMTable
		#-----------------------
		# load & store the register that will use later on
		mv	t4, a0	 	# Content of transfered
		sw	t4, 0(a1)	# store s2 into 0(a1)
		
		addi	a1, a1, 4	# append a1 by 4
		sw	a1, 20(sp)
		
		addi	s0, s0, 4	# append s0 by 4
		addi	s1, s1, 4	# append s1 by 4
		lw	t2, 0(s0)	# load t2 = 0(s0)
		li	t0, 0xFFFFFFFF	# load t0 = -1
		bne  	t2, t0, TransferrenewLoop1	# jump back to the begining of the loop of t2 != -1
		j	TransferrenewLoop2	# jump to TransferrenewLoop2
		#--------------------------------------------------------------
		
	
	
	TransferrenewLoop2:
		# This is the subroutine for the seconde pass that 
		# used for translate offset in riscv instructions to arm instructions
		#--------------------------------------------------------------
		# this block is used for ppreparing registers that will use later on
		# s2 -->> the begining of a1
		lw	s2, 12(sp)	
		li	t0, 1			# t0 = 1
		sw	t0, secondPass, t1 	# store the value into secondPass
		
		lw	a0, 60(sp)		# load a0
		mv	s0, a0			# s0 = a0

		li	s5, 0			# s5 = 0
		sw	s5, 28(sp)		# store s5 into stack
		
		Innerloop2:
		# This is the main loop for the seconde pass that 
		# used for translate offset in riscv instructions to arm instructions
		#--------------------------------------------------------------
		# this block is used for indentify which kind of instructions should 
		# be translated ( branch instruction or alu instruction )
		lw	s5, 28(sp)		# load s5
		addi	s5, s5, 1		# s5 += 1
		sw	s5, 28(sp)		# store s5
		sw	s5, num, t0
		lw	a0, 0(s0)		# a0 = 0(s0)
		slli	s3, a0, 25		# get the 20th bit
		srli	s3, s3, 31
		li	t3, 1			# t3 = 1
		bne	s3, t3, TransferAluloop2	# Jumo to TransferAluloop2 if s3 == 0
		
		jal	ra, translateControl	# jump to translateALU
		
		# Content of transfered
		mv	t4, a0		# first instruction
		mv	s4, a1		# second instruction

		beq	s4, zero, storeJALRLoop2	# Jump to storeJALRLoop2 if we are translating JALR insrtuction
		
		#--------------------------------
		# This block is used for calculating the correct for arm branch instructions
		la	t0, num		# load num
		lw	t1, 0(t0)	
		addi	t1, t1, -1	# t1 -= 1
		slli	t1, t1, 2	# t1 = t1 * 4
	
		# Load the address of 2 tables
		la	t2, RISCTOARMTable	
		la	t3, BranchTable
	
		add	t2, t2, t1	# t2 += t1
		add	t3, t3, t1	# t3 += t1
	
		lw	s8, 0(t2)	# Value in RISCV Table To ARM
		lw	s9, 0(t3)	# Value in Branch Table
	
		#ARM branch address
		addi	s8, s8, 0x04	# s8 += 4
		#ARM branch target
		lw	s10, 0(s9)	# load the value in 0(s9)
		#ARM branch offset
		sub	s10, s10, s8	# s10 -= s8
		li	s11, 0x08	# s11 = 8
		sub	s10, s10, s11	# s10 -= s11
		srai	s10, s10, 2	# arithmetic shift right by 2
		#------
		# store the offset into the branch instructions
		slli	s10, s10, 8
		srli	s10, s10, 8
		
		or	s4, s4, s10
		#--------------------------------
		# load & store the register that will use later on
		sw	t4, 0(s2)	# store s2 into 0(a1)
		sw	s4, 4(s2)		
		
		addi	s2, s2, 8	# append a1 by 4
		sw	s2, 12(sp)
		
		addi	s0, s0, 4	# append s0 by 4

		lw	t2, 0(s0)	# load t2 = 0(s0)
		li	t0, 0xFFFFFFFF	# load t0 = -1
		bne  	t2, t0, Innerloop2	# jump back to the begining of the loop of t2 != -1
		j	QuitRToARenew	# jump to QuitRToARenew
		
		storeJALRLoop2:
		# this block is used for store translated JALR instructions
		sw	t4, 0(s2)	# store s2 into 0(a1)
		
		addi	s2, s2, 4	# append a1 by 4
		sw	s2, 12(sp)
		
		addi	s0, s0, 4	# append s0 by 4

		lw	t2, 0(s0)	# load t2 = 0(s0)
		li	t0, 0xFFFFFFFF	# load t0 = -1
		bne  	t2, t0, Innerloop2	# jump back to the begining of the loop of t2 != -1
		j	QuitRToARenew	# jump to QuitRToARenew
		
		TransferAluloop2:
		# This blcok is used for storing translated alu instructions
		addi	s2, s2, 4	# append a1 by 4
		sw	s2, 12(sp)
		
		addi	s0, s0, 4	# append s0 by 4

		lw	t2, 0(s0)	# load t2 = 0(s0)
		li	t0, 0xFFFFFFFF	# load t0 = -1
		bne  	t2, t0, Innerloop2	# jump back to the begining of the loop of t2 != -1
		j	QuitRToARenew
		
	QuitRToARenew:
		# This block move the result into a0 
		# And restore all the registers before quit the function
		mv	a0, s1		# set a0 to the Number of byte that instructions generated 
		lw	ra, 0(sp)	# restore all the register that used
		lw	s0, 4(sp)
		lw	s1, 8(sp)
		lw	s2, 12(sp)
		lw	s3, 16(sp)
		lw	s4, 24(sp)
		lw	s5, 28(sp)
		lw	s6, 32(sp)
		lw	s7, 36(sp)
		lw	s8, 44(sp)
		lw	s9, 48(sp)
		lw	s10, 52(sp)
		lw	s11, 56(sp)
		addi	sp, sp, 64
		jalr	zero, ra, 0	# return
	
	
#-------------------------------------------------------------------------------------------------------------------------
# translateControl
# This function translates a single RISC-V beq, bge or jalr instruction into either one or two ARM instructions.
# Arguments:
# a0: untranslated RISC-V instruction.
# Return Values:
# a0: first translated ARM instruction. This should either be a wholly tanslated BX instruction, or a CMP instruction.
# a1: 0 or second translated ARM instruction. When non-zero, it should return a branch with 0 offset.
#-------------------------------------------------------------------------------------------------------------------------
translateControl:

	# Block description:
	# create space for the stack and store all the registers
	addi	sp, sp, -36
	sw	ra, 0(sp)
	sw	s0, 4(sp)
	sw	s1, 8(sp)	# s register
	sw	s2, 12(sp)	# t register
	sw	s3, 16(sp)
	sw	a0, 20(sp)
	sw	s4, 24(sp)
	sw	s5, 28(sp)
	sw	s6, 32(sp)
	#-----------------
	# This block identify whcih kind of instructions
	# should be translated
	mv	s0, a0		# s0 = a0
	slli	t0, s0, 19	# shift left s0 by 19 bits
	srli	t0, t0, 31	# shift right s0 by 31 bits
	bne	t0, zero, BGE	# jump to BGE if t0 == 1
	
	slli	t1, s0, 29	# shift left s0 by 29 bits
	srli	t1, t1, 31	# shift right s0 by 31 bits
	bne	t1, zero, JALR	# Jump to JALR if t1 == 1
	j	BEQ		# Jump to BEQ
	
	
	BGE:
	# this block is used to transfer BGE instructions
	# Instructions : 1010 0001 0101 0000
	li	s4, 0xE1500000
	li	s5, 0xAA000000
	#-----------------------
	# s register
	# this block is used to transfer the s register in riscv into arm register
	slli	s1, s0, 12		# get the register in riscv instruction
	srli	s1, s1, 27
	mv	a0, s1			# move a0 = s1
	jal	ra, translateRegister
	mv	s1, a0			# set s1 to the RISCV s register ---> the arm register Rn 
	#-----------------------
	# t register
	# this block is used to transfer the t register in riscv into arm register
	slli	s2, s0, 7		# get the register in riscv instruction
	srli	s2, s2, 27
	mv	a0, s2			# move a0 = s2
	jal	ra, translateRegister
	mv	s2, a0			# set s2 to the RISCV t register ---> the arm register Rm 
	#-----------------------
	# store all the register and opcode into s5 and return arm instruction into a0
	slli	s1, s1, 16
	or	s4, s4, s1
	or	s4, s4, s2
	mv	a0, s4
	mv	a1, s5
	
	j	QuittranslateControl	# Jump to QuittranslateControl
	

	JALR:
	
	li	s4, 0xE12FFF10
	#-----------------------
	# Rd register
	# this block is used to transfer the Rd register in riscv into arm register
	slli	s1, s0, 12		# get the register in riscv instruction
	srli	s1, s1, 27
	mv	a0, s1			# move a0 = s1
	jal	ra, translateRegister
	mv	s1, a0			# set s4 to the RISCV s register ---> the arm register Rn 
	#-----------------------
	# store all the register and opcode into s5 and return arm instruction into a0
	or	s4, s4, s1
	li	t2, 0
	mv	a1, t2
	mv	a0, s4
	#-----------------------
	j	QuittranslateControl	# Jump to QuittranslateControl
	
	BEQ:
	# Instructions: conditions 0001 0101 
	li	s4, 0xE1500000
	li	s5, 0x0A000000
	#-----------------------
	# s register
	# this block is used to transfer the s register in riscv into arm register
	slli	s1, s0, 12		# get the register in riscv instruction
	srli	s1, s1, 27
	mv	a0, s1			# move a0 = s1
	jal	ra, translateRegister
	mv	s1, a0			# set s1 to the RISCV s register ---> the arm register Rn 
	#-----------------------
	# t register
	# this block is used to transfer the t register in riscv into arm register
	slli	s2, s0, 7		# get the register in riscv instruction
	srli	s2, s2, 27
	mv	a0, s2			# move a0 = s2
	jal	ra, translateRegister
	mv	s2, a0			# set s2 to the RISCV t register ---> the arm register Rm 

	#-----------------------
	# store all the register and opcode into s5 and return arm instruction into a0
	slli	s1, s1, 16
	or	s4, s4, s1
	or	s4, s4, s2
	mv	a0, s4
	mv	a1, s5
	
	j	QuittranslateControl	# Jump to QuittranslateControl
	
	
	QuittranslateControl:
	# This block move the result into a0 
	# And restore all the registers before quit the function
	lw	ra, 0(sp)
	lw	s0, 4(sp)
	lw	s1, 8(sp)
	lw	s2, 12(sp)
	lw	s3, 16(sp)
	lw	s4, 24(sp)
	lw	s5, 28(sp)
	lw	s6, 32(sp)
	addi	sp, sp, 36
	jalr	zero, ra, 0	# return 
	
#-------------------------------------------------------------------------------------------------------------------------
# calculateRISCVBranchOffset
# This function performs simple computations to calculate the RISC-V branch offset. Negative values calculated by this function should be returned with proper sign extension.
# Arguments:
# a0: RISC-V instruction.
# Return Values:
# a0: branch offset
#-------------------------------------------------------------------------------------------------------------------------	
caculateRISCVBranchOffset:
	# Block description:
	# create space for the stack and store all the registers
	addi	sp, sp, -28
	sw	ra, 0(sp)
	sw	s0, 4(sp)
	#------------------
	# s1, s2, s3, s4 are used for shifting to get the imm value for riscv instruction	
	sw	s1, 8(sp)	
	sw	s2, 12(sp)	
	sw	s3, 16(sp)
	sw	a0, 20(sp)
	sw	s4, 24(sp)
	#------------------------------------------------------
	# This block is used for get imm value from instruction
	mv	s0, a0
	slli	s1, s0, 20
	srli	s1, s1, 28	# s1 --> [4:1]
	slli	s2, s0, 1
	srli	s2, s2, 26
	slli	s2, s2, 4
	or	s1, s1, s2	# s1 --> [10:1]
	slli	s3, s0, 24
	srli	s3, s3, 31
	slli	s3, s3, 10	
	or	s1, s1, s3	# s1 --> [11:1]
	srli	s4, s0, 31
	slli	s4, s4, 11
	or	s1, s1, s4	# s1 --> [12:1]
	#------------------------------------------------------
	slli	s1, s1, 1	# shift to 13 bits s1 --> [12:0]
	#------------------------------------------------------
	# Get 32 bits value (sign extended)
	slli	s1, s1, 19
	srai	s1, s1, 19
	# This block move the result into a0 
	# And restore all the registers before quit the function
	mv	a0, s1
	lw	ra, 0(sp)
	lw	s0, 4(sp)
	lw	s1, 8(sp)
	lw	s2, 12(sp)
	lw	s3, 16(sp)
	lw	s4, 24(sp)
	addi	sp, sp, 28
	jalr	zero, ra, 0	# return 
	
	
